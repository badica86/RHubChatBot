// This final script handles data requests, AI questions, and logs usage/unanswered questions.
function doPost(e) {
  try {
    const params = JSON.parse(e.postData.contents);

    // Log every interaction to the Usage Log
    logToActionSheet('Usage Log', [
      new Date(),
      params.partnerName || 'Unknown',
      params.language || 'en',
      params.action,
      params.question || params.chatHistory || params.answer
    ]);

    // Route the request based on the action
    switch (params.action) {
      case 'askAI':
        return handleAiRequest(params);
      case 'summarize':
        return handleSummarizeRequest(params);
      case 'elaborate':
      case 'simplify':
        return handleEnhanceRequest(params);
      default:
        return createJsonResponse({error: "Invalid action specified."});
    }
  } catch (error) {
    return createJsonResponse({error: "Invalid request format: " + error.toString()});
  }
}

// doGet is used for fetching the initial sheet data.
function doGet(e) {
    return handleSheetRequest(e.parameter);
}

function handleSheetRequest(params) {
  const sheetName = params.sheet || 'Knowledge'; 
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);

  if (!sheet) {
    return createJsonResponse({error: "The sheet named '" + sheetName + "' was not found."});
  }

  const data = sheet.getDataRange().getValues();
  
  if (sheetName === 'Partner Handbook') {
      const handbookText = data.map(row => row.join(" ")).join("\n");
      return createJsonResponse({handbookContent: handbookText});
  }

  const content = (sheetName.startsWith('Knowledge')) ? data.slice(2) : data.slice(1);
  
  return createJsonResponse(content);
}

function handleAiRequest(params) {
  const userMessage = params.question.toLowerCase().trim();
  const language = params.language || 'English';
  
  // --- Handle "Thank You" ---
  const thankYouPhrases = ['thank you', 'thanks', 'cheers', 'much appreciated', 'multumesc', 'gracias', 'dziękuję', 'спасибо'];
  if (thankYouPhrases.some(phrase => userMessage.includes(phrase))) {
      let response = "You're welcome! Is there anything else I can help with?";
      switch(language.toLowerCase()) {
          case 'romanian': response = "Cu plăcere! Vă mai pot ajuta cu altceva?"; break;
          case 'spanish': response = "¡De nada! ¿Hay algo más en lo que pueda ayudar?"; break;
          case 'polish': response = "Proszę bardzo! Czy mogę w czymś jeszcze pomóc?"; break;
          case 'russian': response = "Пожалуйста! Могу ли я чем-нибудь еще помочь?"; break;
      }
      return createJsonResponse({ answer: response, isCourtesy: true }); 
  }

  // --- Handle "Yes" ---
  const yesPhrases = ['yes', 'yep', 'ok', 'da', 'si', 'tak', 'okay'];
  if (yesPhrases.includes(userMessage)) {
      let response = "Great, what is your question?";
       switch(language.toLowerCase()) {
          case 'romanian': response = "Perfect, care este întrebarea dumneavoastră?"; break;
          case 'spanish': response = "¡Estupendo! ¿Cuál es su pregunta?"; break;
          case 'polish': response = "Świetnie, jakie jest Twoje pytanie?"; break;
          case 'russian': response = "Отлично, какой у вас вопрос?"; break;
      }
      return createJsonResponse({ answer: response, isCourtesy: true });
  }

  // --- Handle "No" and other closing phrases ---
  const noPhrases = ['no', 'nope', 'that is all', 'nu', 'niet', 'nie'];
  if (noPhrases.includes(userMessage)) {
      let response = "Okay, have a great day!";
       switch(language.toLowerCase()) {
          case 'romanian': response = "În regulă, o zi excelentă!"; break;
          case 'spanish': response = "¡De acuerdo, que tengas un buen día!"; break;
          case 'polish': response = "Dobrze, miłego dnia!"; break;
          case 'russian': response = "Хорошо, отличного дня!"; break;
      }
      return createJsonResponse({ answer: response, isCourtesy: true });
  }


  const knowledgeBaseText = params.context;
  const handbookContext = params.handbookContext;

  const prompt = `You are a friendly and helpful assistant for the John Lewis Partnership Resource Hub.
    Your task is a multi-step process:
    1. The user will ask a question in a specific language. First, you must internally translate the user's question to English to understand its meaning.
    2. **PRIORITY 1:** Search the "KNOWLEDGE BASE (FAQs)" section FIRST to find a direct, specific answer. If you find a clear match, provide that answer.
    3. **PRIORITY 2:** If and ONLY IF you cannot find a direct answer in the FAQs, then you may search the "PARTNER HANDBOOK" for more general information.
    4. Finally, you MUST translate your final answer accurately into the user's original language, which is: ${language}.

    **CRITICAL FORMATTING RULES:**
    - **DO NOT use any markdown formatting.**
    - **DO NOT use asterisks (*), dashes (-), or any other characters for bullet points or emphasis.**
    - **DO NOT use '---' or '***' as dividers.**
    - Use simple titles for sections (e.g., "Sickness Entitlement").
    - Separate all paragraphs and sections with a single blank line.
    - Your final output must be clean, readable text.

    Do not show your internal translation or thinking steps. Only output the final, formatted, and translated answer.

    If the information is not in the knowledge base, your ONLY output should be a polite message in ${language} stating that you don't have information on that topic.

    --- KNOWLEDGE BASE (FAQs) START ---
    ${knowledgeBaseText}
    --- KNOWLEDGE BASE (FAQs) END ---

    --- PARTNER HANDBOOK (for detailed information) START ---
    ${handbookContext}
    --- PARTNER HANDBOOK (for detailed information) END ---

    User's Question (in ${language}): "${params.question}"`;

  const aiResponseObject = JSON.parse(callGeminiAPI(prompt).getContent());

  const responseText = aiResponseObject.answer || "";
  if (responseText.includes("don't have information on that topic") || responseText.includes("nu am informații")) {
      logToActionSheet('Unanswered Questions', [new Date(), params.question]);
      aiResponseObject.isCourtesy = true;
  }

  return createJsonResponse(aiResponseObject);
}

function handleSummarizeRequest(params) {
    const chatHistory = params.chatHistory;
    const language = params.language || 'English';
    const prompt = `Please provide a concise summary of the following conversation. The summary MUST be in ${language}. **CRITICAL FORMATTING RULES: Do not use bullet points or asterisks. Use simple paragraphs.** --- CONVERSATION HISTORY --- ${chatHistory} --- END OF HISTORY ---`;
    return callGeminiAPI(prompt);
}

function handleEnhanceRequest(params) {
    const { action, question, answer, language, handbookContext } = params;
    let prompt;
    if (action === 'elaborate') {
        prompt = `A user asked: "${question}". The initial answer was: "${answer}". Please elaborate on this answer with more detail, using the Partner Handbook context if relevant. The final response MUST be in ${language}. **CRITICAL FORMATTING RULES: Do not use markdown. Use simple titles and blank lines.** --- PARTNER HANDBOOK CONTEXT --- ${handbookContext || "N/A"} --- END OF CONTEXT ---`;
    } else { // simplify
        prompt = `A user asked: "${question}". The initial answer was: "${answer}". Please simplify this answer into the plainest terms possible. The final response MUST be in ${language}. **CRITICAL FORMATTING RULES: Do not use markdown.**`;
    }
    return callGeminiAPI(prompt);
}


function callGeminiAPI(prompt) {
  try {
    const apiKey = "AIzaSyBLD2jnwASGkeeuRyqi5p82sMTT2CMJNPA";
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
    const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
    const options = { method: 'post', contentType: 'application/json', payload: JSON.stringify(payload), muteHttpExceptions: true };
    const response = UrlFetchApp.fetch(apiUrl, options);
    const responseCode = response.getResponseCode();
    const responseBody = response.getContentText();

    if (responseCode === 200) {
      const result = JSON.parse(responseBody);
      let botResponse = "Sorry, I couldn't find an answer to that.";
       if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
           botResponse = result.candidates[0].content.parts[0].text;
       }
      return createJsonResponse({ answer: botResponse });
    } else {
      return createJsonResponse({ error: `AI API request failed with status ${responseCode}`, details: JSON.parse(responseBody) });
    }
  } catch (error) {
    return createJsonResponse({ error: `Error calling Gemini API: ${error.toString()}` });
  }
}

function logToActionSheet(sheetName, dataArray) {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);
    if (sheet) {
      sheet.appendRow(dataArray);
    }
  } catch (e) {
    // Fails silently to not interrupt the user experience.
    console.error("Logging failed for sheet " + sheetName + ": " + e.toString());
  }
}

function createJsonResponse(data) {
  return ContentService
    .createTextOutput(JSON.stringify(data))
    .setMimeType(ContentService.MimeType.JSON);
}
